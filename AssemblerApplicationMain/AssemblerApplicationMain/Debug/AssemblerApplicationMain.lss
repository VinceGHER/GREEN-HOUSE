
AVRASM ver. 2.2.6  C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm Sun May 30 12:56:20 2021

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(8): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/macros.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(9): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/definitions.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(12): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\interruption.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(15): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/lcd.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(16): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/printf.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(17): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/wire1.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(20): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\manager.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(21): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/encoder.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/encoder.asm(15): warning: Register r21 already defined by the .DEF directive
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(21): 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/encoder.asm' included form here
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(22): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/temperature.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(23): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/musicdef.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(24): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/music.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(25): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/motor.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(28): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\reset.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(8): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/macros.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(9): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/definitions.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(12): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\interruption.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(15): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/lcd.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(16): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/printf.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(17): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\libraries/wire1.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(20): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\manager.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(21): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/encoder.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(22): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/temperature.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(23): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/musicdef.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(24): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/music.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(25): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\drivers/motor.asm'
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(28): Including file 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\reset.asm'
                                 
                                 ; file:	main.asm   
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: main file of the project
                                 ; authors: Vincent Gherold & Alain Schbi
                                 
                                 
                                 ; === macros and definitions ===
                                 .include "libraries/macros.asm"
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	pop	@0
                                 	pop	@1
                                 	pop	@2
                                 	pop	@3
                                 	pop	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 .include "libraries/definitions.asm"
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 
                                 ; === interruption ===
                                 .include "interruption.asm"
                                 
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: interruption vector
                                 ; authors: Vincent Gherold & Alain Schbi
                                 
                                 
                                 .org 0					; Reset
000000 c34c                      	rjmp reset
                                 .org	INT0addr		; External Interrupt Request 0
000002 9518                      	reti
                                 .org	INT1addr		; External Interrupt Request 1
000004 9518                      	reti
                                 .org	INT2addr		; External Interrupt Request 2
000006 9518                      	reti
                                 .org	INT3addr		; External Interrupt Request 3
000008 9518                      	reti
                                 .org	INT4addr		; External Interrupt Request 4
00000a 9518                      	reti
                                 .org	INT5addr		; External Interrupt Request 5
00000c 9518                      	reti
                                 .org	INT6addr		; External Interrupt Request 6
00000e 9518                      	reti
                                 .org	INT7addr		; External Interrupt Request 7
000010 9518                      	reti
                                 .org	OC2addr			; Timer/Counter2 Compare Match
000012 c316                      	rjmp iMotorLogic
                                 .org	OVF2addr		; Timer/Counter2 Overflow
000014 9518                      	reti 
                                 .org	ICP1addr		; Timer/Counter1 Capture Event
000016 9518                      	reti
                                 .org	OC1Aaddr		; Timer/Counter1 Compare Match A
000018 940c 01fe                 	jmp iTimer1TemperatureRequest
                                 .org	OC1Baddr		; Timer/Counter Compare Match B
00001a 9518                      	reti
                                 .org	OVF1addr		; Timer/Counter1 Overflow
00001c 9518                      	reti
                                 .org	OC0addr			; Timer/Counter0 Compare Match
00001e c2bc                      	rjmp iBpm
                                 .org	OVF0addr		; Timer/Counter0 Overflow
000020 9518                      	reti
                                 .org	SPIaddr			; SPI Serial Transfer Complete
000022 9518                      	reti
                                 .org	URXC0addr		; USART0, Rx Complete
000024 9518                      	reti
                                 .org	UDRE0addr		; USART0 Data Register Empty
000026 9518                      	reti
                                 .org	UTXC0addr		; USART0, Tx Complete
000028 9518                      	reti
                                 .org	ADCCaddr		; ADC Conversion Complete
00002a 9518                      	reti
                                 .org	ERDYaddr		; EEPROM Ready
00002c 9518                      	reti
                                 .org	ACIaddr			; Analog Comparator
00002e 9518                      	reti
                                 .org	OC1Caddr		; Timer/Counter1 Compare Match C
000030 9518                      	reti
                                 .org	ICP3addr		; Timer/Counter3 Capture Event
000032 9518                      	reti
                                 .org	OC3Aaddr		; Timer/Counter3 Compare Match A
000034 c2a0                      	rjmp iFrequency
                                 .org	OC3Baddr		; Timer/Counter3 Compare Match B
000036 9518                      	reti
                                 .org	OC3Caddr		; Timer/Counter3 Compare Match C
000038 9518                      	reti
                                 .org	OVF3addr		; Timer/Counter3 Overflow
00003a 9518                      	reti
                                 
                                 
                                 .org 0x46
                                 
                                 ; === libraries ===
                                 .include "libraries/lcd.asm"
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
000046 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
000048 fc37
000049 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
00004a d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
00004b 9300 8000                 	sts	LCD_IR, w		; store w in IR
00004d 9508                      	ret
                                 	
                                 lcd_4us:
00004e d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
00004f 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
000050 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
000051 302d
000052 f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
000053 302a
000054 f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
000055 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
000057 fd07
000058 cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
000059 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
00005a 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
00005c 9508                      	ret	
                                 	
00005d e001
00005e cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
00005f e002
000060 cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
000061 e100
000062 cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
000063 e104
000064 cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
000065 e108
000066 cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
000067 e10c
000068 cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
000069 e00d
00006a cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
00006b e00c
00006c cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
00006d e00e
00006e cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
00006f e00c
000070 cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
000071 b705                      	in	w,MCUCR					; enable access to ext. SRAM
000072 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
000073 bf05                      	out	MCUCR,w
000074 e001
000075 dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
000076 e006
000077 dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
000078 e00c
000079 dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
00007a e308
00007b dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
00007c 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
00007d 2f02                      	mov	w,a0
00007e 6800                      	ori	w,0b10000000
00007f cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
000080 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
000082 fd07
000083 cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
000084 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
000085 6800                      	ori	w,0b10000000		; write address command
000086 dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
000087 9300 8000                 	sts	LCD_IR,w			; store in IR
000089 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
00008a 932f                      	push	a0				; safeguard a0
00008b e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
00008c dff0                      	rcall	LCD_pos			; set cursor position
00008d 912f                      	pop	a0					; restore a0
                                 .include "libraries/printf.asm"
00008e 9508                      
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having bit7 set to 1.
                                 
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	60..ff	SRAM registers (warning: extended i/o in AVR128)
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
00008f 91ff
000090 91ef                      	POPZ			; z points to begin of "string"
000091 0fee
000092 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
000093 93af
000094 93bf                      	PUSHX
                                 		
                                 _printf_read:
000095 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
000096 9631                      	adiw	zl,1	; increment pointer Z
000097 2000                      	tst	r0			; test for ZERO (=end of string)
000098 f021                      	breq	_printf_end	; char=0 indicates end of ascii string
000099 f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
00009a 2d00                      	mov	w,r0
00009b d013                      	rcall	_putw	; display the character
00009c cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
00009d 9631                      	adiw	zl,1	; point to the next character
00009e 95f6
00009f 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
0000a0 91bf
0000a1 91af                      	POPX
0000a2 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
0000a3 fa00                      	bst	r0,0		; store sign in T
0000a4 2d00                      	mov	w,r0		; store formatting character in w
                                 
0000a5 95c8                      	lpm	
0000a6 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
0000a7 27bb                      	clr	xh			; clear high-byte
0000a8 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
0000a9 3804
0000aa f079                      	JK	w,FCHAR,_putchar
0000ab 3805
0000ac f081                      	JK	w,FSTR ,_putstr
0000ad c015                      	rjmp	_putnum
                                 	
0000ae cfe6                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
0000af 932f
0000b0 93ff
0000b1 93ef                      	PUSH3	a0,zh,zl
0000b2 2de4
0000b3 2df5
0000b4 2f20                      	MOV3	a0,zh,zl, w,e1,e0
0000b5 9509                      	icall			; indirect call to "putc"
0000b6 91ef
0000b7 91ff
0000b8 912f                      	POP3	a0,zh,zl
0000b9 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
0000ba 910c                      	ld	w,x
0000bb dff3                      	rcall	_putw
0000bc cfd8                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
0000bd 910d                      	ld	w,x+
0000be 2300                      	tst	w
0000bf f409                      	brne	PC+2
0000c0 cfd4                      	rjmp	_printf_read
0000c1 dfed                      	rcall	_putw
0000c2 cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
0000c3 935f
0000c4 934f
0000c5 933f
0000c6 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
0000c7 939f
0000c8 938f
0000c9 937f
0000ca 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
0000cb 912d
0000cc 913d
0000cd 914d
0000ce 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
0000cf fd06
0000d0 c006                      	JB1	w,6,_putdec
0000d1 fd05
0000d2 c00f                      	JB1	w,5,_putbin
0000d3 fd04
0000d4 c010                      	JB1	w,4,_puthex
0000d5 fd03
0000d6 c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
0000d7 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
0000d8 2f70                      	mov	b1,w
0000d9 9576                      	lsr	b1
0000da 7077                      	andi	b1,0b111	
0000db 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000dc e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
0000dd 2f90                      	mov	b3,w
0000de 9592                      	swap	b3
0000df 7093                      	andi	b3,0b11
0000e0 9593                      	inc	b3			; b3 = number of bytes (1..4)
0000e1 c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
0000e2 e062                      	ldi	b0,2		; b0 = base (2)
0000e3 e094                      	ldi	b3,4		; b3 = number of bytes (4)	
0000e4 c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
0000e5 e160                      	ldi	b0,16		; b0 = base (16)
0000e6 e094                      	ldi	b3,4		; b3 = number of bytes (4)
0000e7 c000                      	rjmp	_getdig
                                 
                                 _getdig:
0000e8 2f70                      	mov	b1,w
0000e9 9576                      	lsr	b1
0000ea 7077                      	andi	b1,0b111
0000eb f409                      	brne	PC+2
0000ec e078                      	ldi	b1,8		; if b1=0 then 8-digits
0000ed 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000ee e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
0000ef c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
0000f0 e06a                      	ldi	b0,10		; base=10	
0000f1 95c8                      	lpm
0000f2 2d80                      	mov	b2,r0		; load dec.point position
0000f3 9631                      	adiw	zl,1	; increment char pointer
0000f4 95c8                      	lpm
0000f5 2d70                      	mov	b1,r0		; load ii.ff format
0000f6 9631                      	adiw	zl,1	; increment char pointer
                                 	
0000f7 2f90                      	mov	b3,w
0000f8 9595                      	asr	b3
0000f9 7093                      	andi	b3,0b11
0000fa 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
0000fb c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
0000fc 3094
0000fd f081                      	JK	b3,4,_printf_4b
0000fe 3093
0000ff f051                      	JK	b3,3,_printf_3b
000100 3092
000101 f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
000102 2733                      	clr	a1
000103 f416                      	brtc	PC+3	; T=1 sign extension
000104 fd27                      	sbrc	a0,7
000105 ef3f                      	ldi	a1,0xff
                                 _printf_2b:
000106 2744                      	clr	a2
000107 f416                      	brtc	PC+3	; T=1 sign extension	
000108 fd37                      	sbrc	a1,7
000109 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
00010a 2755                      	clr	a3
00010b f416                      	brtc	PC+3	; T=1 sign extension
00010c fd47                      	sbrc	a2,7
00010d ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
00010e d009                      	rcall	_ftoa		; float to ascii
00010f 916f
000110 917f
000111 918f
000112 919f                      	POP4	b3,b2,b1,b0	; restore b
000113 912f
000114 913f
000115 914f
000116 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
000117 cf7d                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
000118 92cf                      	push	d0
000119 92bf
00011a 92af
00011b 929f
00011c 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
00011d 18bb
00011e 24aa
00011f 2499
000120 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
000121 f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
000122 94e8                      	clt
000123 2355                      	tst	a3				; if MSb(a)=1 then a=-a
000124 f46a                      	brpl	_ftoa_plus
000125 9468                      	set					; T=1 (minus)
000126 2377                      	tst	b1
000127 f009                      	breq	PC+2		; if b1=0 the print ALL digits
000128 5170                      	subi	b1,0x10		; decrease int digits
000129 9550
00012a 9540
00012b 9530
00012c 9520
00012d ef0f
00012e 1b20
00012f 0b30
000130 0b40
000131 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
000132 2388                      	tst	b2				; b0=0 (only integer part)
000133 f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
000134 9555
000135 9547
000136 9537
000137 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000138 94b7
000139 94a7
00013a 9497
00013b 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
00013c 958a
00013d f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
00013e 937f                      	push	b1			; ii.ff (ii=int digits)
00013f 9572                      	swap	b1
000140 707f                      	andi	b1,0x0f
                                 	
000141 e20e                      	ldi	w,'.'			; push decimal point
000142 930f                      	push	w
                                 _ftoa_int1:
000143 d045                      	rcall	_div41		; int=int/10
000144 2d0c                      	mov	w,d0			; d=reminder
000145 d030                      	rcall	_hex2asc
000146 930f                      	push	w			; push rem(int/10)
000147 2700
000148 1720
000149 0730
00014a 0740
00014b 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
00014c f029                      	breq	_ftoa_space	; (int/10)=0 then finished
00014d 2377                      	tst	b1
00014e f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
00014f 957a
000150 f791                      	DJNZ	b1,_ftoa_int1
000151 c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
000152 2377                      	tst	b1				; if b1=0 then print ALL int-digits
000153 f029                      	breq	_ftoa_sign
000154 957a                      	dec	b1
000155 f019                      	breq	_ftoa_sign
000156 e200                      	ldi	w,' '			; write spaces
000157 df57                      	rcall	_putw	
000158 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000159 f416                      	brtc	PC+3		; if T=1 then write 'minus'
00015a e20d                      	ldi	w,'-'
00015b df53                      	rcall	_putw
                                 _ftoa_int3:
00015c 910f                      	pop	w
00015d 320e                      	cpi	w,'.'
00015e f011                      	breq	PC+3
00015f df4f                      	rcall	_putw
000160 cffb                      	rjmp	_ftoa_int3
                                 
000161 917f                      	pop	b1				; ii.ff (ff=frac digits)
000162 707f                      	andi	b1,0x0f
000163 2377                      	tst	b1
000164 f059                      	breq	_ftoa_end
                                 _ftoa_point:	
000165 df49                      	rcall	_putw		; write decimal point
000166 2d28
000167 2d39
000168 2d4a
000169 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
00016a d011                      	rcall	_mul41		; d.frac=10*frac
00016b 2d0c                      	mov	w,d0
00016c d009                      	rcall	_hex2asc
00016d df41                      	rcall	_putw
00016e 957a
00016f f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
000170 908f
000171 909f
000172 90af
000173 90bf                      	POP4	c3,c2,c1,c0
000174 90cf                      	pop	d0
000175 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
000176 300a                      	cpi	w,10
000177 f410                      	brsh	PC+3
000178 5d00                      	addi	w,'0'
000179 9508                      	ret
00017a 5a09                      	addi	w,('a'-10)
00017b 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
00017c 24cc                      _mul41:	clr	d0			; clear byte4 of result
00017d e200                      	ldi	w,32			; load bit counter
00017e 9488                      __m41:	clc				; clear carry
00017f fd20                      	sbrc	a0,0		; skip addition if LSB=0
000180 0ec6                      	add	d0,b0			; add b to MSB of a
000181 94c7
000182 9557
000183 9547
000184 9537
000185 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
000186 950a
000187 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
000188 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
000189 24cc                      _div41:	clr	d0			; d will contain the remainder
00018a e200                      	ldi	w,32			; load bit counter
00018b 1f22
00018c 1f33
00018d 1f44
00018e 1f55
00018f 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
000190 1ac6                      	sub	d0, b0			; subtract b from remainder
000191 f408                      	brcc	PC+2	
000192 0ec6                      	add	d0, b0			; restore if remainder became negative
000193 950a
000194 f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
000195 1f22
000196 1f33
000197 1f44
000198 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
000199 9550
00019a 9540
00019b 9530
00019c 9520                      	COM4	a3,a2,a1,a0	; complement result
00019d 9508                      	ret
                                 .include "libraries/wire1.asm"
                                 
                                 ; purpose Dallas 1-wire(R) interface library
                                 
                                 ; === definitions ===
                                 .equ	DQ_port	= PORTD
                                 .equ	DQ_pin	= DQ
                                 
                                 .equ	DS18B20		= 0x28
                                 
                                 .equ	readROM		= 0x33
                                 .equ	matchROM	= 0x55
                                 .equ	skipROM		= 0xcc
                                 .equ	searchROM	= 0xf0
                                 .equ	alarmSearch	= 0xec
                                 
                                 .equ	writeScratchpad	= 0x4e
                                 .equ	readScratchpad	= 0xbe
                                 .equ	copyScratchpad	= 0x48
                                 .equ	convertT	= 0x44
                                 .equ	recallE2	= 0xb8
                                 .equ	readPowerSupply	= 0xb4
                                 
                                 ; === routines ===
                                 
                                 .macro	WIRE1	; t0,t1,t2
                                 	sbi	DQ_port-1,DQ_pin	; pull DQ low (DDR=1 output)
                                 	ldi	w,(@0+1)/2	
                                 	rcall	wire1_wait		; wait low time (t0)
                                 	cbi	DQ_port-1,DQ_pin	; release DQ (DDR=0 input)
                                 	ldi	w,(@1+1)/2	
                                 	rcall	wire1_wait		; wait high time (t1)
                                 	in	w,DQ_port-2			; sample line (PINx=PORTx-2)
                                 	bst	w,DQ_pin			; store result in T
                                 	ldi	w,(@2+1)/2	
                                 	rcall	wire1_wait		; wait separation time (t2)
                                 	ret
                                 	.endmacro	
                                 
                                 wire1_wait:
00019e 950a                      	dec	w					; loop time 2usec
00019f 0000                      	nop
0001a0 0000                      	nop
0001a1 0000                      	nop
0001a2 0000                      	nop
0001a3 0000                      	nop
0001a4 f7c9                      	brne	wire1_wait
0001a5 9508                      	ret
                                 
                                 wire1_init:
0001a6 9895                      	cbi	DQ_port,  DQ_pin	; PORT=0 low (for pull-down)
0001a7 988d                      	cbi	DQ_port-1,DQ_pin	; DDR=0 (input hi Z)
0001a8 9508                      	ret
                                 	
0001a9 9a8d
0001aa ef0f
0001ab dff2
0001ac 988d
0001ad e203
0001ae dfef
0001af b300
0001b0 fb05
0001b1 ec0d
0001b2 dfeb
0001b3 9508                      wire1_reset:	WIRE1	510,70,410 ; instead of 480, 70, 410
0001b4 9a8d
0001b5 e10c
0001b6 dfe7
0001b7 988d
0001b8 e002
0001b9 dfe4
0001ba b300
0001bb fb05
0001bc e001
0001bd dfe0
0001be 9508                      wire1_write0:	WIRE1	56,4,1
0001bf 9a8d
0001c0 e001
0001c1 dfdc
0001c2 988d
0001c3 e10e
0001c4 dfd9
0001c5 b300
0001c6 fb05
0001c7 e001
0001c8 dfd5
0001c9 9508                      wire1_write1:	WIRE1	1,59,1
0001ca 9a8d
0001cb e001
0001cc dfd1
0001cd 988d
0001ce e007
0001cf dfce
0001d0 b300
0001d1 fb05
0001d2 e107
0001d3 dfca
0001d4 9508                      wire1_read1:	WIRE1	1,14,45
                                 	
                                 wire1_write:
0001d5 933f                      	push	a1
0001d6 e038                      	ldi	a1,8
0001d7 9527                      	ror	a0
                                 
0001d8 f410                      	brcc	PC+3				; if C=1 then wire1, else wire0
0001d9 dfe5                      	rcall	wire1_write1
0001da c001                      	rjmp	PC+2
0001db dfd8                      	rcall	wire1_write0
                                 
0001dc 953a
0001dd f7c9                      	DJNZ	a1,wire1_write+2	; dec and jump if not zero
0001de 913f                      	pop	a1	
0001df 9508                      	ret
                                 
                                 wire1_read:
0001e0 933f                      	push	a1
0001e1 e038                      	ldi	a1,8
0001e2 9527                      	ror	a0
0001e3 dfe6                      	rcall	wire1_read1			; returns result in T
0001e4 f927                      	bld	a0,7					; move T to MSb
0001e5 953a
0001e6 f7d9                      	DJNZ	a1,wire1_read+2		; dec and jump if not zero
0001e7 913f                      	pop	a1	
0001e8 9508                      	ret
                                 	
                                 wire1_crc:
0001e9 e109                      	ldi	w,0b00011001
0001ea e048                      	ldi	a2,8
0001eb 9527                      crc1:	ror	a0
0001ec f408                      	brcc	PC+2
0001ed 2730                      	eor	a1,w
0001ee fb30                      	bst	a1,0
0001ef 9537                      	ror	a1
0001f0 f937                      	bld	a1,7
0001f1 954a
0001f2 f7c1                      	DJNZ	a2,crc1
0001f3 9508                      
                                 ; === subroutines and code ===
                                 .include "manager.asm"
                                 
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: manager file of the project, 
                                 ;			   contains subroutines to control the LCD, the initliasation of timers...
                                 ; authors: Vincent Gherold & Alain Schbi
                                 
                                 
                                 
                                 
                                 ; === SRAM bytes ===
                                 .dseg
000100                           	sReadTemperatureRequest:	.byte	1  ; 1 byte in the SRAM at adress sACTIVITYTIME
                                 .cseg
                                 
                                 .set TIMER1COMPARE = 256 * 16
                                 
                                 
                                 ; === subroutines ===
                                 ; --- initReadTemperatureTimer ---
                                 ; initiliazes timer1
                                 ; mod w 
                                 ; ---
                                 initReadTemperatureTimer:
0001f4 e00d
0001f5 bd0e                      	OUTI TCCR1B, (1<<CTC10) + 5				  ; set CTC10 for clear on output compare
0001f6 e100
0001f7 bd0b                      	OUTI OCR1AH, high(TIMER1COMPARE)		  ; define OCR1AH 
0001f8 e000
0001f9 bd0a                      	OUTI OCR1AL, low(TIMER1COMPARE)			  ; define OCR1AL 
                                 
0001fa b707                      	in w, TIMSK
0001fb 6100                      	ori w, (1<<OCIE1A)						  ; set OCIE1A for output compare mode
0001fc bf07                      	out TIMSK, w	
0001fd 9508                      ret
                                 
                                 
                                 ; --- iTimer1TemperatureRequest ---
                                 ; interruption of timer1, increments sReadTemperatureRequest
                                 ; ---
                                 iTimer1TemperatureRequest:
0001fe 930f                      	push w
0001ff 9100 0100
000201 9503
000202 9300 0100                 	INCS sReadTemperatureRequest			  ; (only modifies w, SREG = CST)
000204 910f                      	pop w
000205 9518                      	reti
                                 
                                 
                                 ; --- loadingLCDTemperature ---
                                 ; displays loading on the first line of the LCD
                                 ; mod a0, b0, b1, w, u, e0, e1, SREG
                                 ; out LCD
                                 ; ---
                                 loadingLCDTemperature:
000206 e020                      	ldi a0, 0x00                              ; start writing at the first line of the LCD
000207 de75                      	rcall LCD_pos
000208 e501
000209 2e40
00020a e000
00020b 2e50
00020c de82                      	PRINTF LCD
00020d 6f6c
00020e 6461
00020f 6e69
000210 2e67
000211 2e2e
000212 0000                      	.db "loading...", 0, 0 ;
000213 9508                      	ret
                                 
                                 
                                 ; --- updateLCDTemperature ---
                                 ; displays sTEMP on the first line of the LCD
                                 ; in sTEMPl, sTEMPh
                                 ; mod a0, b0, b1, w, u, e0, e1, SREG
                                 ; out LCD
                                 ; ---
                                 updateLCDTemperature:
000214 9170 0102                 	lds b1, sTEMPh
000216 9160 0103                 	lds b0, sTEMPl
000218 e020                      	ldi a0, 0x00                               ; start writing at the first line of the LCD
000219 940e 007d                 	call LCD_pos
00021b e501
00021c 2e40
00021d e000
00021e 2e50
00021f de6f                      	PRINTF LCD
000220 6341
000221 7574
000222 6c65
000223 656c
000224 203a
000225 168a
000226 2204
000227 0020
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\manager.asm(69): warning: .cseg .db misalignment - padding zero byte
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(20): 'C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\manager.asm' included form here
000228 0000                      	.db "Actuelle: ", FFRAC2, b, 4, $22, " ", 0, 0
000229 9508                      	ret
                                 	
                                 
                                 ; --- updateLCDEncoder ---
                                 ; displays rENCOD on the second line of the LCD
                                 ; in rENCOD, parameterIn2, parameterIn3
                                 ; mod a0, w, u, e0, e1, SREG
                                 ; out LCD
                                 ; ---
                                 updateLCDEncoder:
00022a e420                      	ldi a0, 0x40							    ; start writing at the second line of the LCD
00022b 940e 007d                 	call LCD_pos
00022d e501
00022e 2e40
00022f e000
000230 2e50
000231 de5d                      	PRINTF LCD
000232 430a
000233 6e6f
000234 6973
000235 6e67
000236 3a65
000237 8820
000238 0215
000239 2022
00023a 0000                      	.db  LF, "Consigne: ", FFRAC, rENCODAddr, 2, $22, " ", 0, 0
00023b 9508                      	ret
                                 
                                 
                                 
                                 
                                 
                                 .include "drivers/encoder.asm"
                                 
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: encoder library, controls the angular position 
                                 ;              and sets the flag T if there was a change
                                 ; authors: Vincent Gherold & Alain Schbi
                                 
                                 
                                 
                                 ; === definitions ===
                                 ; .equ	ENCOD_A	= 4	; angular encoder A
                                 ; .equ	ENCOD_B	= 5	; angular encoder B
                                 ; .equ	ENCOD_I	= 6	; angular encoder button 
                                 .equ	PORTENCOD	 = PORTE
                                 .equ	MASKENCOD    = (1<<ENCOD_A) + (1<<ENCOD_B) + (1<<ENCOD_I)
                                 .def	rENCOD	     = r21	  ; r21 = a3
                                 .equ	rENCODAddr	 = 21	  ; r21 = a3
                                 .equ	ENCODMIN     = 15*4   ; minimum value of the encoder, [1;254]
                                 .equ	ENCODMAX     = 30*4   ; maximum value of the encoder, [1;254] & >= ENCODMIN
                                 .equ	ENCODDEFAULT = 20*4   ; default value of the encoder, ENCODMIN <=  ENCODDEFAULT <= ENCODMAX
                                 
                                 ; === SRAM bytes ===
                                 .dseg
000101                           	sENCOLD:	.byte	1  ; 1 byte in the SRAM at adress sENCOLD
                                 .cseg
                                 
                                 
                                 
                                 
                                 ; === subroutines ===
                                 
                                 ; --- initEncoder ---
                                 ; initializes the encoder
                                 ; mod w, rENCOD
                                 ; ---
                                 initEncoder:
00023c b102                      	in	 w, PORTENCOD-1		    ; define PORTENCOD as an input (DDR of the port)
00023d 780f                      	andi w, ~MASKENCOD
00023e b902                      	out	 PORTENCOD-1, w
                                 
00023f b103                      	in	w, PORTENCOD		    ; enable the internal pull-ups, avoids having to branch extern resistors
000240 6700                      	ori	w, MASKENCOD
000241 b903                      	out	PORTENCOD, w
                                 
000242 e550                      	ldi rENCOD, ENCODDEFAULT   	; set rENCOD to the default value
                                 
000243 9508                      	ret
                                 
                                 
                                 
                                 ; --- encoder ---
                                 ; checks the encoder status and actualizes rENCOD and the flag T
                                 ; mod w, u, flag T, sENCOLD
                                 ; out rENCOD
                                 ; ---
                                 encoder:
                                 	
000244 94e8                      	clt						; clear flag T
000245 b101                      	in	  w, PORTENCOD-2	; read encoder port (w=new)
000246 7700                      	andi  w, MASKENCOD		; mask encoder lines (A,B,I)
000247 9030 0101                 	lds	  u, sENCOLD		; load previous value (u=encd_old)
                                 
000249 1503                      	cp	  w, u			    ; new - old = w - u
00024a f409                      	brne  PC+2				; if (w != u) -> jump to PC+2
00024b 9508                      	ret						; return (as nothing as changed)
                                 
00024c 9300 0101                 	sts	 sENCOLD, w		    ; store encoder value for next time
00024e 2630                      	eor	 u, w				; exclusive or detects transitions, 
                                 							; u = "transitions"
                                 							; w = "new state"
                                 
00024f fe34                      	sbrs	u, ENCOD_A		; if (bit ENCOD_A of u == 1) -> PC = PC + 2	
000250 9508                      	ret						; return (no transition on A)	
                                 
                                 aTransition:
000251 9468                      	set						; set flag T
000252 fd04                      	sbrc	w, ENCOD_A	    ; if A rises/falls
000253 c003                      	rjmp	aRise
                                 aFall:
000254 ff05                      	sbrs w, ENCOD_B
000255 c008                      	rjmp rENCODDec
000256 c002                      	rjmp rENCODInc
                                 
                                 aRise:
000257 fd05                      	sbrc w, ENCOD_B
000258 c005                      	rjmp rENCODDec
                                 
                                 
                                 rENCODInc:
000259 9553                      	inc	 rENCOD				; rENCOD++
                                 checkMax:
00025a 3759                      	cpi  rENCOD, ENCODMAX+1
00025b f008                      	brcs PC+2				; if ( rENCOD < rENCODMAX+1 ) -> return
                                 reachedMax:
00025c e758                      	ldi  rENCOD, ENCODMAX	; set rENCOD to the maximum value
00025d 9508                      	ret
                                 
                                 
                                 rENCODDec:
00025e 955a                      	dec rENCOD				; rENCOD--
                                 checkMin:
00025f 335c                      	cpi  rENCOD, ENCODMIN
000260 f408                      	brcc PC+2				; if ( rENCOD >= rENCODMIN ) -> return
                                 reachedMin:
000261 e35c                      	ldi  rENCOD, ENCODMIN	; set rENCOD to the minimum value
                                 .include "drivers/temperature.asm"
000262 9508                      
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: Dallas 1-wire(R) temperature sensor interfacing, Module M5
                                 ; authors: Vincent Gherold & Alain Schbi
                                 
                                 
                                 ; === SRAM bytes ===
                                 .dseg
000102                           		sTEMPh: .byte 1
000103                           		sTEMPl: .byte 1
                                 .cseg
                                 
                                 
                                 ; === subroutines ===
                                 ; --- aquireTemp ---
                                 ; aquire temperature 
                                 ; mod a0, w, SREG
                                 ; out sTEMPh, sTEMPl
                                 ; ---
                                 aquireTemp:
000263 df45                      	rcall	wire1_reset				; send a reset pulse
000264 ec2c
000265 df6f                      	CA	wire1_write, skipROM		; skip ROM identification
000266 e424
000267 df6d                      	CA	wire1_write, convertT		; initiate temp conversion
                                 
000268 9508                      	ret
                                 
                                 
                                 ; --- readTemp ---
                                 ; read temperature 
                                 ; mod a0, w, SREG
                                 ; out sTEMPh, sTEMPl
                                 ; ---
                                 readTemp:
000269 df3f                      	rcall	wire1_reset				; send a reset pulse
00026a ec2c
00026b df69                      	CA	wire1_write, skipROM
00026c eb2e
00026d df67                      	CA	wire1_write, readScratchpad	
00026e df71                      	rcall	wire1_read				; read temperature LSB
00026f 9320 0103                 	sts	sTEMPl, a0
000271 df6e                      	rcall	wire1_read				; read temperature MSB
000272 9320 0102                 	sts	sTEMPh, a0
                                 
000274 9508                      	ret
                                 .include "drivers/musicdef.asm"	; first include macros which are used in music.asm
                                 
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: music definitions
                                 ; authors: Vincent Gherold & Alain Schbi
                                 
                                 
                                 
                                 ; === macros ===
                                 
                                 ; --- PLAYPARTITION ---
                                 ; loads a specific music partition and starts music
                                 ; in partitionAdress @0
                                 ; mod sMUSIC, w (from startBpm)
                                 ; out plays music
                                 ; ---
                                 .macro PLAYPARTITION
                                 	lds w, ETIMSK			; if (no music playing (OCEI3A == 0)) -> startMusic
                                 	sbrc w, OCIE3A
                                 	rjmp endPlayPartitionMacro
                                 
                                 playMusic:
                                 	SETsMUSIC @0
                                 	rcall startBpm
                                 
                                 endPlayPartitionMacro:
                                 .endmacro
                                 
                                 
                                 ; --- SETsMUSIC ---
                                 ; loads a specific music partition
                                 ; in partitionAdress @0
                                 ; mod sMUSIC
                                 ; out sMUSIC
                                 ; ---
                                 .macro SETsMUSIC
                                 	ldi w, high(@0*2)
                                 	sts sMUSIC+1, w
                                 
                                 	ldi w, low(@0*2)
                                 	sts sMUSIC, w
                                 .endmacro
                                 
                                 
                                 
                                 
                                 ; === constants ===
                                 
                                 ; === frequencies ===
                                 ; octave 2
                                 .equ freqC  = 15905
                                 .equ freqCs = 15012
                                 .equ freqD  = 14169
                                 .equ freqDs = 13374
                                 .equ freqE  = 12624
                                 .equ freqF  = 11915
                                 .equ freqFs = 11246
                                 .equ freqG  = 10615
                                 .equ freqGs = 10019
                                 .equ freqA  = 9457
                                 .equ freqAs = 8926
                                 .equ freqB  = 8425
                                 
                                 
                                 
                                 .cseg ; programm memory (optionnal)
000275 0000
000276 2bee
000277 2977
000278 2723
000279 24f1
00027a 22de
00027b 20e9
00027c 1f10
00027d 1d52
00027e 1bac
00027f 1a1f
000280 18a8
000281 1745
000282 15f7
000283 14bb
000284 1391
000285 1278
000286 116f
000287 1074
000288 0f88
000289 0ea9
00028a 0dd6
00028b 0d0f
00028c 0c54
00028d 0ba2
00028e 0afb
00028f 0a5d
000290 09c8
000291 093c
000292 08b7
000293 083a
000294 07c4                      	frequencies: .dw 0, freqFs/1, freqG/1, freqGs/1, freqA/1, freqAs/1, freqB/1, freqC/2, freqCs/2, freqD/2, freqDs/2, freqE/2, freqF/2, freqFs/2, freqG/2, freqGs/2, freqA/2, freqAs/2, freqB/2, freqC/4, freqCs/4, freqD/4, freqDs/4, freqE/4, freqF/4, freqFs/4                                 , freqG/4, freqGs/4, freqA/4, freqAs/4, freqB/4, freqC/8
                                 
                                 
                                 
                                 ; === notes ===
                                 .equ nRest = 0
                                 .equ nFs3 = 1 
                                 .equ nG3 = 2 
                                 .equ nGs3 = 3 
                                 .equ nA3 = 4 
                                 .equ nAs3 = 5 
                                 .equ nB3 = 6 
                                 .equ nC4 = 7 
                                 .equ nCs4 = 8 
                                 .equ nD4 = 9 
                                 .equ nDs4 = 10 
                                 .equ nE4 = 11 
                                 .equ nF4 = 12 
                                 .equ nFs4 = 13 
                                 .equ nG4 = 14 
                                 .equ nGs4 = 15 
                                 .equ nA4 = 16 
                                 .equ nAs4 = 17 
                                 .equ nB4 = 18 
                                 .equ nC5 = 19 
                                 .equ nCs5 = 20 
                                 .equ nD5 = 21 
                                 .equ nDs5 = 22 
                                 .equ nE5 = 23 
                                 .equ nF5 = 24 
                                 .equ nFs5 = 25 
                                 .equ nG5 = 26 
                                 .equ nGs5 = 27 
                                 .equ nA5 = 28 
                                 .equ nAs5 = 29 
                                 .equ nB5 = 30 
                                 .equ nC6 = 31 
                                 
                                 
                                 
                                 ; === length ===
                                 .equ LMul = 32
                                 
                                 .equ Noire        = 1 * LMul ;       -> 0010 0000 = 0x20 (no transform)
                                 .equ Blanche      = 2 * LMul ;       -> 0100 0000 = 0x40 (no transform)
                                 .equ BlancheP     = 3 * LMul ;       -> 0110 0000 = 0x60 (no transform)
                                 .equ Ronde        = 4 * LMul ;       -> 1000 0000 = 0x80 (no transform)
                                 .equ RondeP       = 6 * LMul ;       -> 1100 0000 = 0xc0 (no transform)
                                 
                                 .equ DoubleCroche = 5 * LMul ;       -> 0000 1000 = 0x08 (transform)
                                 .equ Croche		  = 7 * LMul ;       -> 0001 0000 = 0x10 (transform)
                                 
                                 ; 0 * LMul is not used, otherwise a nRest of this duration would be interpreted as the end of the partiion
                                 
                                 
                                 
                                 ; === partition ===
000295 2b26
000296 eeeb
000297 4b2d
000298 7032
000299 2b6d
00029a eeeb
00029b 4a2d
00029c 662c
00029d 0000                      .cseg ; programm memory (optionnal)
                                 	harryPotter: .db nB3+Noire, nE4+Noire, nE4+Croche, nG4+Croche, nFs4+Noire, nE4+Blanche, nB4+Noire, nA4+BlancheP, nFs4+BlancheP, nE4+Noire, nE4+Croche, nG4+Croche, nFs4+Noire, nDs4+Blanche, nF4+Noire, nB3+BlancheP, 0, 0
                                 
00029e 6e67
00029f ebec
0002a0 73e9
0002a1 ee2e
0002a2 ebec
0002a3 73e9
0002a4 ee2e
0002a5 ebec
0002a6 69ec
0002a7 e020
0002a8 0000                      .cseg ; programm memory (optionnal)
                                 	starWars: .db nC4+BlancheP, nG4+BlancheP, nF4+Croche, nE4+Croche, nD4+Croche, nC5+BlancheP, nG4+Noire, nG4+Croche, nF4+Croche, nE4+Croche, nD4+Croche, nC5+BlancheP, nG4+Noire, nG4+Croche, nF4+Croche, nE4+Croche, nF4+Croche, nD4+BlancheP, nRest+Noire, nRe                                 st+Croche, 0, 0
0002a9 0090                      
                                 .include "drivers/music.asm"
                                 
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: generates music on the buzzer connected on PORTBUZZER
                                 ;			   uses timer0 for the bpm and timer3 for the frequencies
                                 ; authors: Vincent Gherold & Alain Schbi
                                 	
                                 
                                 
                                 ; === definitions ===
                                 .equ PORTBUZZER = PORTE
                                 
                                 
                                 ; === SRAM bytes ===
                                 .dseg
000104                           	sMUSIC:	.byte	2  ; 1 word (16 bits) in the SRAM at adress sMUSICh
                                 .cseg
                                 
                                 
                                 ; === subroutines ===
                                 ; --- initBeep ---
                                 ; initliazes the music, the buzzer, and the timer0
                                 ; mod w, timer0, sMUSIC
                                 ; ---	
                                 initMusic:
0002aa 9a12                      	sbi	PORTBUZZER-1, SPEAKER	; defines SPEAKER as an output (DDR of the port)
0002ab e008
0002ac bf00                      	OUTI ASSR, (1<<AS0)         ; chose TOSC (32768 Hz) for TIMER0
0002ad e00e
0002ae bf03                      	OUTI TCCR0, (1<<CTC0) + 6	; prescaler:  CS0 = 6, prescaler = 256, freq = 32768/256 = 128Hz	
0002af e000
0002b0 9300 0105
0002b2 e000
0002b3 9300 0104                 	SETsMUSIC 0					; initialize sMUSIC to 0
0002b5 9508                      	ret
                                 	
                                 
                                 
                                 ; --- startBpm ---
                                 ; starts the bpm (timer3) and thus starts the music
                                 ; mod w
                                 ; out timer0, timer3
                                 ; ---
                                 startBpm:
                                 
0002b6 e001
0002b7 bf01                      	OUTI OCR0, 0x01							  ; (modifies w) to directly call iBpm
                                 
0002b8 e000
0002b9 bf02                      	OUTI TCNT0, 0							  ; clears the TCNT of the timer0 and timer3
0002ba e000
0002bb 9300 0089                 	OUTEI TCNT3H, 0
0002bd e000
0002be 9300 0088                 	OUTEI TCNT3L, 0
                                 
0002c0 e008
0002c1 9300 008a                 	OUTEI TCCR3B, (1<<CTC30) + (0<<CS30)      ; desactivate timer3 until the first call of iBpm
                                 
0002c3 b707                      	in w, TIMSK
0002c4 6002                      	ori w, (1<<OCIE0)						  ; set OCIE0 for output compare mode
0002c5 bf07                      	out TIMSK, w	
                                 	
0002c6 9100 007d                 	lds w, ETIMSK							  ; set OCIE3A for output compare mode
0002c8 6100                      	ori w, (1<<OCIE3A)
0002c9 9300 007d                 	sts ETIMSK, w        
                                 
0002cb 9508                      	ret
                                 
                                 
                                 ; --- stopBpm ---
                                 ; stops the bpm (timer3) and thus stops the music
                                 ; mod w
                                 ; out timer0, timer3
                                 ; ---
                                 stopBpm: 
0002cc b707                      	in w, TIMSK				    ; stops bpm timer (timer0)
0002cd 7f0d                      	andi w, ~(1<<OCIE0)					
0002ce bf07                      	out TIMSK, w
                                 
0002cf 9100 007d                 	lds w, ETIMSK				; stops frequency timer (timer3)
0002d1 7e0f                      	andi w, ~(1<<OCIE3A)
0002d2 9300 007d                 	sts ETIMSK, w
                                 
0002d4 9508                      	ret
                                 
                                 
                                 ; --- iFrequency ---
                                 ; output compare interruption of timer3, inverses the speaker voltage 
                                 ; ---	
                                 iFrequency:
0002d5 9b1a
0002d6 c002
0002d7 981a
0002d8 c001
0002d9 9a1a                      	INVP PORTBUZZER, SPEAKER   ; inverse speaker voltage (SREG = CST)
0002da 9518                      	reti
                                 	
                                 
                                 
                                 
                                 ; --- iBpm ---
                                 ; compare overflow of timer3, loads next note
                                 ; in  sMUSIC
                                 ; mod sMUSIC, timer0, timer3, _sreg
                                 ; out sMUSIC, timer0, timer3
                                 ; ---	
                                 iBpm:
0002db b61f                      	in _sreg, SREG			            ; save context
0002dc 920f                      	push r0
0002dd 930f                      	push w
0002de 93ef
0002df 93ff                      	PUSHZ								; (SREG = CST)
                                 
0002e0 91e0 0104
0002e2 91f0 0105                 	LDSZ sMUSIC 						; load pointer z with the adress of sMUSIC (SREG = CST)
                                 							
0002e4 95c8                      	lpm						            ; load programm memory into r0
0002e5 2000                      	tst	r0					            ; test for zero or minus
0002e6 f171                      	breq endOfPartition		            ; if (r0 == 0) -> endOfPartition
                                 
0002e7 9631                      	adiw z, 1							; increment pointer z
0002e8 93e0 0104
0002ea 93f0 0105                 	STSZ sMUSIC							; store the value of z at the sMUSIC
                                 
0002ec 2d00                      	mov w, r0				            ; move r0
0002ed 7e00                      	andi w, 0b11100000		            ; take the 3 MSB, which stand for the note's length
                                 
                                 	; musicdef.asm note length transform rules	
0002ee 3e00                      	cpi w, 7*LMul						; Croche				
0002ef f409                      	brne PC+2
0002f0 e100                      	ldi w, 0x10 
0002f1 3a00                      	cpi w, 5*LMul						; DoubleCroche
0002f2 f409                      	brne PC+2
0002f3 e008                      	ldi w, 0x08 
                                 
0002f4 bf01                      	out OCR0, w				            ; set the note length (timer0)
                                 
0002f5 2d00                      	mov w, r0 				            ; move r0
0002f6 710f                      	andi w, 0b00011111		            ; take the 5 LSB, which stand for the note's pitch
0002f7 0f00                      	add w, w				            ; multiply by 2, for the lpm adressing standard
                                 
0002f8 2fe0
0002f9 27ff
0002fa 51e6
0002fb 4ffb                      	LDZD 2*frequencies, w               ; (only modifies SREG)
                                 
0002fc 95c8                      	lpm						            ; loads programm memory into r0
0002fd 2d00                      	mov w, r0				            ; we now use r0:w as the frequency byte
0002fe 9631                      	adiw zl, 1				            ; increments pointer z
                                 	
0002ff 95c8                      	lpm						            ; loads programm memory into r0
000300 2000                      	tst r0
000301 f079                      	breq playRest
000302 2300                      	tst w
000303 f069                      	breq playRest
                                 
000304 9200 0087                 	sts OCR3AH, r0					    ; set the OCR3A byte according to the frequency (r0:w)
000306 9300 0086                 	sts OCR3AL, w
                                 
000308 e009
000309 9300 008a                 	OUTEI TCCR3B, (1<<CTC30) + (1<<CS30); activates timer3, as it was maybe playing a nRest (modifies w)
                                 
                                 retiBpm:	
00030b 91ff
00030c 91ef                      	POPZ			                    ; return form interrupt, restore context
00030d 910f                      	pop w
00030e 900f                      	pop r0
00030f be1f                      	out SREG, _sreg		
000310 9518                      	reti
                                 
                                 playRest:								; desactive timer3 to play a nRest
000311 e008
000312 9300 008a                 	OUTEI TCCR3B, (1<<CTC30) + (0<<CS30)
000314 cff6                      	rjmp retiBpm
                                 
                                 endOfPartition:			                ; stops bpm timer (timer0)
000315 b707                      	in w, TIMSK
000316 7f0d                      	andi w, ~(1<<OCIE0)					
000317 bf07                      	out TIMSK, w
                                 
000318 9100 007d                 	lds w, ETIMSK						; stops frequency timer (timer3)
00031a 7e0f                      	andi w, ~(1<<OCIE3A)
00031b 9300 007d                 	sts ETIMSK, w
                                 
                                 .include "drivers/motor.asm"
00031d cfed                      
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: file to control S3003 FUTABA Servo motor
                                 ; authors: Vincent Gherold & Alain Schbi
                                 
                                 ; === definitions ===
                                 .equ SERVOPIN = 5
                                 .equ PORTMOTOR = PORTB      ; defines the port of motor
                                 
                                 
                                 ; === SRAM bytes ===
                                 .dseg
000106                           		sMOTORHIGH: .byte 1
000107                           		sMOTORLOW:	.byte 1
                                 .cseg
                                 
                                 ; === macros ===
                                 ; --- STSI ---
                                 ; store value direct in register 
                                 ; in SRAM adress, value
                                 ; mod w
                                 ; out SRAM
                                 ; ---
                                 .macro STSI
                                 	ldi w, @1
                                 	sts @0, w
                                 .endmacro
                                 
                                 
                                 ; --- OUTLDS ---
                                 ; store I/O register from register 
                                 ; in I/O register, sram register
                                 ; mod w
                                 ; out I/O
                                 ; ---
                                 .macro OUTLDS
                                 	lds w, @1
                                 	out @0, w
                                 .endmacro
                                 
                                 
                                 ; === subroutines ===
                                 ; --- initMotor ---
                                 ; initializes the motor, the PORTMOTOR, the timer2 
                                 ; mod w, PORTMOTOR, timer2, sMOTORHIGH, sMOTORLOW
                                 ; ---
                                 initMotor:
00031e b307                      	in w, PORTMOTOR-1				; configure PORTMOTOR as output
00031f 6200                      	ori w, (1<<SERVOPIN)
000320 bb07                      	out PORTMOTOR-1, w
                                 
000321 98c5                      	P0		PORTMOTOR, SERVOPIN     ; set line to low
                                 
000322 e00d
000323 bd05                      	OUTI  TCCR2, (1<<CTC2) + 5		; prescaler:  CS2 = 5, prescaler = 1024, freq = 4000/128 = 3.9 kHz, period = 256 us
000324 d01a                      	rcall openWindow				; open window by default
                                 
000325 b707                      	in w, TIMSK
000326 6800                      	ori w, (1<<OCIE2)				; set OCIE2 for output compare mode
000327 bf07                      	out TIMSK, w	  
000328 9508                      	ret
                                 
                                 
                                 ; --- iMotorLogic ---
                                 ; interruption of timer2, controls the signal sent to the motor
                                 ; mod _sreg, timer2
                                 ; out timer2
                                 ; ---
                                 iMotorLogic:
000329 b61f                      	in _sreg, SREG					; save context
00032a 930f
00032b 931f                      	PUSH2 w, _w
                                 
00032c b503                      	in w, OCR2						; loads current output compare register OCR2
00032d 9110 0106                 	lds _w, sMOTORHIGH				; loads sMOTORHIGH
00032f 1701                      	cp w, _w						; if (OCR2 != sMOTORHIGH) -> set line to low
000330 f429                      	brne notEqual					; if (OCR2 == sMOTORHIGH) -> set line to high
000331 98c5                      	P0	PORTMOTOR, SERVOPIN			; set PORTMOTOR to 0
                                 	
000332 9100 0107
000334 bd03                      	OUTLDS OCR2, sMOTORLOW			; set OCR2 to sMOTORLOW
000335 c005                      	rjmp final
                                 
                                 notEqual:
000336 9ac5                      	P1		PORTMOTOR, SERVOPIN		; set PORTMOTOR to 1
000337 9100 0106
000339 bd03                      	OUTLDS	OCR2, sMOTORHIGH		; set OCR2 to sMOTORHIGH
00033a c000                      	rjmp final
                                 
                                 final:
00033b 911f
00033c 910f                      	POP2 w, _w						; restore context
00033d be1f                      	out SREG, _sreg					
00033e 9518                      	reti
                                 
                                 
                                 ; --- openWindow ---
                                 ; changes the duration of the HIGH and LOW period of the signal sent to the motor (to open the window)
                                 ; mod w (from STSI), sMOTORHIGH, sMOTORLOW
                                 ; out sMOTORHIGH, sMOTORLOW
                                 ; ---
                                 openWindow:
00033f e003
000340 9300 0106                 	STSI 	sMOTORHIGH, 3   
000342 e40c
000343 9300 0107                 	STSI	sMOTORLOW, 76   
000345 9508                      	ret
                                 
                                 ; --- closeWindow ---
                                 ; changes the duration of the HIGH and LOW period of the signal sent to the motor (to close the window)
                                 ; mod w (from STSI), sMOTORHIGH, sMOTORLOW
                                 ; out sMOTORHIGH, sMOTORLOW
                                 ; ---
                                 closeWindow:
000346 e007
000347 9300 0106                 	STSI 	sMOTORHIGH, 7   
000349 e408
00034a 9300 0107                 	STSI	sMOTORLOW, 72
00034c 9508                      	ret
                                 
                                 
                                 
                                 
                                 ; === reset ===
                                 .include "reset.asm"
                                 
                                 ; target: ATmega128L-4MHz-STK300
                                 ; description: reset code
                                 ; authors: Vincent Gherold & Alain Schbi
                                 
                                 reset:
                                 	; === global initialisation ===
00034d ef0f
00034e bf0d
00034f e100
000350 bf0e                      	LDSP RAMEND                     ; initialize stack pointer	
000351 94f8                      	cli								; clear global interrupt
000352 e000
000353 bf07                      	OUTI TIMSK, 0x00                ; desactivate all timers
                                 	
                                 	; === drivers initialisation ===
000354 de9f                      	rcall initReadTemperatureTimer
000355 df54                      	rcall initMusic
000356 dee5                      	rcall initEncoder
000357 dfc6                      	rcall initMotor
                                 
                                 	; === libraries initialisation ===
000358 dd18                      	rcall LCD_init
000359 de4c                      	rcall wire1_init
                                 
                                 	; === other initialisation ===
00035a e000                      	ldi w, 0
00035b 9300 0108                 	sts sTemperatureWasInRange, w	; clear sTemperatureWasInRange
                                 	
00035d dea8                      	rcall loadingLCDTemperature		; displays loading...
                                 
00035e df04                      	rcall aquireTemp				; first aquiring temperature
00035f ee08
000360 2e30
000361 e004
000362 930f
000363 923f
000364 e300
000365 2e30
000366 e006
000367 943a
000368 f7f1
000369 943a
00036a 950a
00036b f7d9
00036c 903f
00036d 910f
00036e 943a
00036f f791
000370 950a
000371 f781                      	WAIT_MS 1000
000372 def6                      	rcall readTemp					; first reading temperatue
000373 dea0                      	rcall updateLCDTemperature		; displays temperature
000374 deb5                      	rcall updateLCDEncoder			; displays encoder
                                 
000375 9478                      	sei								; set global interrupt
000376 940c 0378                 
                                 
                                 ; === constants ===
                                 .set TEMPERATUREINTERVAL = 2 ; seconds [2, 255], actualization interval of the temperature sensor
                                 
                                 .set AQUIRETEMPERATUREREQUESTINTERVAL = TEMPERATUREINTERVAL -1 ; seconds
                                 .set READTEMPERATUREREQUESTINTERVAL = AQUIRETEMPERATUREREQUESTINTERVAL + 1 ; seconds
                                 
C:\Users\alain\OneDrive - epfl.ch\Projet\AAAA_Rendu\AssemblerApplicationMain\AssemblerApplicationMain\project\main.asm(37): warning: float->int cast, truncated
                                 .set TEMPERATUREINTERVAL    = 0.5*4*4	; 0.5C for the window control (avoid openging/closing too often)
                                 .set TEMPERATUREBIGINTERVAL = 1*4*4		; 1C   for the big range (with the music alert, sTemperatureWasInRange)
                                 
                                 .dseg
000108                           	sTemperatureWasInRange: .byte 1		; equals 1 if the temperature was in range, equals 0 otherwise
                                 .cseg
                                 
                                 
                                 ; === main ===
                                 main:		
000378 e001
000379 2e30
00037a e001
00037b 930f
00037c 923f
00037d e300
00037e 2e30
00037f e006
000380 943a
000381 f7f1
000382 943a
000383 950a
000384 f7d9
000385 903f
000386 910f
000387 943a
000388 f791
000389 950a
00038a f781                      	WAIT_MS 1							; (faster than the timer1 interruption)
                                 
00038b 940e 0244                 	call encoder						; call encoder (value into rENCOD)
00038d f42e                      	brtc noEncoderChange
                                 
                                 enncoderChange:
00038e e000                      	ldi w, 0
00038f 9300 0108                 	sts sTemperatureWasInRange, w		; clear sTemperatureWasInRange, as the encoder value has changed
000391 940e 022a                 	call updateLCDEncoder				; displays the new encoder value (consign temperature)
                                 
                                 noEncoderChange:
000393 9100 0100                 	lds w, sReadTemperatureRequest
000395 3001                      	cpi w, AQUIRETEMPERATUREREQUESTINTERVAL
000396 f419                      	brne checkReadTemperatureRequest	; if (sReadTemperatureRequest == AQUIRETEMPERATUREREQUESTINTERVAL) -> call aquireTemp
                                 
                                 aquireTemperatureRequest:
000397 940e 0263                 	call aquireTemp						; (modifies w, a0, SREG)
000399 cfde                      	rjmp main
                                 
                                 checkReadTemperatureRequest:	
00039a 9100 0100                 	lds w, sReadTemperatureRequest
00039c 3002                      	cpi w, READTEMPERATUREREQUESTINTERVAL
00039d f6d1                      	brne main							; if (sReadTemperatureRequest == READTEMPERATUREREQUESTINTERVAL) -> call readTemp
                                 
                                 readTemperatureRequest:
00039e e000                      	ldi w, 0							; reset sReadTemperatureRequest
00039f 9300 0100                 	sts sReadTemperatureRequest, w
                                 
0003a1 940e 0269                 	call readTemp						; (modifies w, a0, SREG)
0003a3 940e 0214                 	call updateLCDTemperature			; (modifies u, w, SREG)
                                 
0003a5 9120 0103                 	lds a0, sTEMPl						; loads sTemph:sTempl in a1:a0
0003a7 9130 0102                 	lds a1, sTEMPh
                                 
0003a9 2f65                      	mov b0, rENCOD						; loads rENCOD in b0, the consign temperature
0003aa e070                      	ldi b1, 0
                                 
0003ab 0f66
0003ac 1f77                      	LSL2 b1, b0							; logical shift left by 2, for the temperature sensor format
0003ad 0f66
0003ae 1f77                      	LSL2 b1, b0
                                 
                                 checkOpenWindow:						; if (actual temperature > consign temperature + TEMPERATUREINTERVAL) 
0003af 2f86
0003b0 2f97                      	MOV2 b3, b2, b1, b0
0003b1 5f88
0003b2 4f9f                      	ADDI2 b3, b2, TEMPERATUREINTERVAL
0003b3 1728
0003b4 0739                      	CP2 a1, a0, b3, b2					
0003b5 f024                      	brlt checkCloseWindow				; if (a - b < 0)  -> jump
0003b6 f019                      	breq checkCloseWindow				; if (a - b == 0) -> jump
0003b7 940e 033f                 	call openWindow						
0003b9 c00f                      	rjmp temperatureWasNotInRange
                                 
                                 checkCloseWindow:						; if (actual temperature < consign temperature - TEMPERATUREINTERVAL) 
0003ba 2f86
0003bb 2f97                      	MOV2 b3, b2, b1, b0
0003bc 5088
0003bd 4090                      	ADDI2 b3, b2, -TEMPERATUREINTERVAL	
0003be 1728
0003bf 0739                      	CP2 a1, a0, b3, b2
                                 
0003c0 f41c                      	brge temperatureWasInRange			; if (a - b > 0)  -> jump
0003c1 940e 0346                 	call closeWindow
0003c3 c005                      	rjmp temperatureWasNotInRange
                                 
                                 temperatureWasInRange:
0003c4 e001                      	ldi w, 1
0003c5 9300 0108                 	sts sTemperatureWasInRange, w	    ; sets sTemperatureWasInRange to 1, as the temperature was in range
0003c7 940c 0378                 	jmp main
                                 
                                 temperatureWasNotInRange:
0003c9 9100 0108                 	lds w, sTemperatureWasInRange
0003cb 2300                      	tst w								; tests if temperature was in range before
0003cc f411                      	brne checkBigRange					; if (temperatureWasInRange != 0) -> checkBigRange
0003cd 940c 0378                 	jmp main
                                 
                                 
                                 checkBigRange:
                                 checkBigRangeHigh:						; if (actual temperature > consign temperature + TEMPERATUREBIGINTERVAL) 
0003cf 2f86
0003d0 2f97                      	MOV2 b3, b2, b1, b0				 
0003d1 5f80
0003d2 4f9f                      	ADDI2 b3, b2, TEMPERATUREBIGINTERVAL
0003d3 1728
0003d4 0739                      	CP2 a1, a0, b3, b2				
0003d5 f08c                      	brlt checkBigRangeLow				; if (a - b < 0)  -> jump
0003d6 f081                      	breq checkBigRangeLow				; if (a - b == 0) -> jump
0003d7 9100 007d
0003d9 fd04
0003da c007
0003db e005
0003dc 9300 0105
0003de e30c
0003df 9300 0104
0003e1 ded4                      	PLAYPARTITION starWars
0003e2 e000                      	ldi w, 0							; reset sReadTemperatureRequest
0003e3 9300 0108                 	sts sTemperatureWasInRange, w
0003e5 940c 0378                 	jmp main
                                 	
                                 checkBigRangeLow:						; if (actual temperature < consign temperature - TEMPERATUREBIGINTERVAL) 
0003e7 2f86
0003e8 2f97                      	MOV2 b3, b2, b1, b0				
0003e9 5180
0003ea 4090                      	ADDI2 b3, b2, -TEMPERATUREBIGINTERVAL
0003eb 1728
0003ec 0739                      	CP2 a1, a0, b3, b2
0003ed f484                      	brge noTemperatureUpdate			; if (a - b >= 0) -> jump
0003ee 9100 007d
0003f0 fd04
0003f1 c007
0003f2 e005
0003f3 9300 0105
0003f5 e20a
0003f6 9300 0104
0003f8 debd                      	PLAYPARTITION harryPotter
0003f9 e000                      	ldi w, 0							; reset sReadTemperatureRequest
0003fa 9300 0108                 	sts sTemperatureWasInRange, w
0003fc 940c 0378                 	jmp main
                                 
                                 noTemperatureUpdate:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   1 r0 :  15 r1 :   4 r2 :   0 r3 :  20 r4 :   4 
r5 :   4 r6 :   0 r7 :   0 r8 :   5 r9 :   5 r10:   5 r11:   6 r12:  11 
r13:   0 r14:   0 r15:   0 r16: 269 r17:   4 r18:  42 r19:  32 r20:  17 
r21:  23 r22:  17 r23:  33 r24:  19 r25:  27 r26:   3 r27:   3 r28:   0 
r29:   0 r30:  18 r31:  12 
Registers used: 26 out of 35 (74.3%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   3 adiw  :   7 and   :   0 
andi  :  15 asr   :   2 bclr  :   0 bld   :   2 brbc  :   0 brbs  :   0 
brcc  :   4 brcs  :   1 break :   0 breq  :  21 brge  :   2 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   2 brmi  :   1 
brne  :  26 brpl  :   1 brsh  :   1 brtc  :   6 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   6 call  :   9 cbi   :   9 cbr   :   0 
clc   :   1 clh   :   0 cli   :   1 cln   :   0 clr   :  11 cls   :   0 
clt   :   2 clv   :   0 clz   :   0 com   :   8 cp    :   7 cpc   :   7 
cpi   :  15 cpse  :   0 dec   :  21 elpm  :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :  17 inc   :   4 
jmp   :   7 ld    :   6 ldd   :   0 ldi   : 108 lds   :  22 lpm   :  21 
lsl   :   3 lsr   :   3 mov   :  42 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   6 or    :   0 ori   :   8 out   :  25 
pop   :  36 push  :  35 rcall :  63 ret   :  38 reti  :  29 rjmp  :  53 
rol   :  12 ror   :  17 sbc   :   3 sbci  :   5 sbi   :   7 sbic  :   0 
sbis  :   1 sbiw  :   0 sbr   :   1 sbrc  :  15 sbrs  :   2 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   2 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :  35 sub   :   3 subi  :   8 swap  :   4 tst   :  12 wdr   :   0 

Instructions used: 65 out of 114 (57.0%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000800   1816    154   1970  131072   1.5%
[.dseg] 0x000100 0x000109      0      9      9    4096   0.2%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 3 warnings
